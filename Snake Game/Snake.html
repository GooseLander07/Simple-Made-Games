<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Colorful Snake Game</title>
    <style>
        body {
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            height: 100vh;
            margin: 0;
            background: linear-gradient(135deg, #1a2a6c, #b21f1f, #fdbb2d);
            font-family: 'Arial', sans-serif;
            overflow: hidden;
        }
        
        #game-container {
            position: relative;
        }
        
        #game-canvas {
            border: 8px solid #333;
            border-radius: 10px;
            box-shadow: 0 0 30px rgba(0, 0, 0, 0.5);
            background-color: #222;
        }
        
        #score-display {
            margin-top: 20px;
            font-size: 24px;
            color: white;
            text-shadow: 2px 2px 4px rgba(0, 0, 0, 0.5);
        }
        
        .controls {
            margin-top: 20px;
            color: white;
            text-align: center;
        }
    </style>
</head>
<body>
    <div id="game-container">
        <canvas id="game-canvas" width="400" height="400"></canvas>
        <div id="score-display">Score: 0</div>
        <div class="controls">
            <p>Use arrow keys to control the snake</p>
        </div>
    </div>

    <script>
        // Game constants
        const GRID_SIZE = 20;
        const TILE_COUNT = 20;
        const INITIAL_SPEED = 150; // ms per move
        
        // Game variables
        let snake = [];
        let food = {};
        let direction = 'right';
        let nextDirection = 'right';
        let score = 0;
        let gameSpeed = INITIAL_SPEED;
        let gameLoop;
        let isGameOver = false;
        
        // Canvas setup
        const canvas = document.getElementById('game-canvas');
        const ctx = canvas.getContext('2d');
        const scoreDisplay = document.getElementById('score-display');
        
        // Initialize game
        function initGame() {
            // Clear any existing game loop
            clearInterval(gameLoop);
            
            // Reset game state
            snake = [];
            direction = 'right';
            nextDirection = 'right';
            score = 0;
            gameSpeed = INITIAL_SPEED;
            isGameOver = false;
            scoreDisplay.textContent = `Score: ${score}`;
            
            // Create initial snake (3 segments)
            for (let i = 2; i >= 0; i--) {
                snake.push({ x: i, y: 0 });
            }
            
            // Generate first food
            generateFood();
            
            // Start game loop
            gameLoop = setInterval(gameStep, gameSpeed);
        }
        
        // Generate food at random position
        function generateFood() {
            let validPosition = false;
            
            while (!validPosition) {
                food = {
                    x: Math.floor(Math.random() * TILE_COUNT),
                    y: Math.floor(Math.random() * TILE_COUNT)
                };
                
                // Check if food is on snake
                validPosition = true;
                for (let segment of snake) {
                    if (segment.x === food.x && segment.y === food.y) {
                        validPosition = false;
                        break;
                    }
                }
            }
        }
        
        // Main game loop
        function gameStep() {
            if (isGameOver) return;
            
            // Update direction
            direction = nextDirection;
            
            // Calculate new head position
            const head = { ...snake[0] };
            
            switch (direction) {
                case 'up':
                    head.y--;
                    break;
                case 'down':
                    head.y++;
                    break;
                case 'left':
                    head.x--;
                    break;
                case 'right':
                    head.x++;
                    break;
            }
            
            // Check for collisions
            if (
                head.x < 0 || head.x >= TILE_COUNT ||
                head.y < 0 || head.y >= TILE_COUNT ||
                snake.some(segment => segment.x === head.x && segment.y === head.y)
            ) {
                gameOver();
                return;
            }
            
            // Add new head
            snake.unshift(head);
            
            // Check if snake ate food
            if (head.x === food.x && head.y === food.y) {
                score++;
                scoreDisplay.textContent = `Score: ${score}`;
                
                // Increase speed slightly every 5 points
                if (score % 5 === 0) {
                    gameSpeed = Math.max(50, gameSpeed - 10);
                    clearInterval(gameLoop);
                    gameLoop = setInterval(gameStep, gameSpeed);
                }
                
                generateFood();
            } else {
                // Remove tail if no food eaten
                snake.pop();
            }
            
            // Draw everything
            drawGame();
        }
        
        // Draw the game state
        function drawGame() {
            // Clear canvas
            ctx.fillStyle = '#222';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            // Draw grid (optional)
            ctx.strokeStyle = '#333';
            ctx.lineWidth = 0.5;
            for (let i = 0; i < TILE_COUNT; i++) {
                for (let j = 0; j < TILE_COUNT; j++) {
                    ctx.strokeRect(i * GRID_SIZE, j * GRID_SIZE, GRID_SIZE, GRID_SIZE);
                }
            }
            
            // Draw snake
            snake.forEach((segment, index) => {
                // Head is different color
                if (index === 0) {
                    ctx.fillStyle = '#4CAF50'; // Head color
                } else {
                    // Gradient body color
                    const hue = (120 + (index * 2)) % 360;
                    ctx.fillStyle = `hsl(${hue}, 80%, 50%)`;
                }
                
                ctx.beginPath();
                ctx.roundRect(
                    segment.x * GRID_SIZE + 1, 
                    segment.y * GRID_SIZE + 1, 
                    GRID_SIZE - 2, 
                    GRID_SIZE - 2, 
                    5
                );
                ctx.fill();
            });
            
            // Draw food (apple)
            ctx.fillStyle = '#FF5252';
            ctx.beginPath();
            ctx.arc(
                food.x * GRID_SIZE + GRID_SIZE / 2,
                food.y * GRID_SIZE + GRID_SIZE / 2,
                GRID_SIZE / 2 - 2,
                0,
                Math.PI * 2
            );
            ctx.fill();
            
            // Add shine to apple
            ctx.fillStyle = 'rgba(255, 255, 255, 0.3)';
            ctx.beginPath();
            ctx.arc(
                food.x * GRID_SIZE + GRID_SIZE / 2 + 3,
                food.y * GRID_SIZE + GRID_SIZE / 2 - 3,
                GRID_SIZE / 6,
                0,
                Math.PI * 2
            );
            ctx.fill();
        }
        
        // Handle game over
        function gameOver() {
            isGameOver = true;
            clearInterval(gameLoop);
            
            // Draw game over text
            ctx.fillStyle = 'rgba(0, 0, 0, 0.75)';
            ctx.fillRect(0, 0, canvas.width, canvas.height);
            
            ctx.fillStyle = 'white';
            ctx.font = '30px Arial';
            ctx.textAlign = 'center';
            ctx.fillText('Game Over!', canvas.width / 2, canvas.height / 2 - 20);
            ctx.font = '20px Arial';
            ctx.fillText(`Final Score: ${score}`, canvas.width / 2, canvas.height / 2 + 20);
            ctx.fillText('Press Space to Restart', canvas.width / 2, canvas.height / 2 + 60);
        }
        
        // Handle keyboard input
        document.addEventListener('keydown', (e) => {
            if (isGameOver && e.code === 'Space') {
                initGame();
                return;
            }
            
            switch (e.key) {
                case 'ArrowUp':
                    if (direction !== 'down') nextDirection = 'up';
                    break;
                case 'ArrowDown':
                    if (direction !== 'up') nextDirection = 'down';
                    break;
                case 'ArrowLeft':
                    if (direction !== 'right') nextDirection = 'left';
                    break;
                case 'ArrowRight':
                    if (direction !== 'left') nextDirection = 'right';
                    break;
            }
        });
        
        // Start the game
        initGame();
    </script>
</body>
</html>